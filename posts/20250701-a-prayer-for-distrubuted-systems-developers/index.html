<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>분산 시스템 개발자를 위한 기도 :: philipjkim</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="... 스택 꼭대기에 서서 아래를 내려다보니, 그동안 제가 보아온 두 가지 유형 — 그리고 어쩌면 세 번째 유형 — 의 소프트웨어 엔지니어링에 대해 생각하게 되었습니다." />
<meta name="keywords" content="assembler, cloud, distributed-systems, programming" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://philipjkim.github.io/posts/20250701-a-prayer-for-distrubuted-systems-developers/" />





  
  <link rel="stylesheet" href="https://philipjkim.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css">

  
  <link rel="stylesheet" href="https://philipjkim.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css">

  
  <link rel="stylesheet" href="https://philipjkim.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css">

  
  <link rel="stylesheet" href="https://philipjkim.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css">

  
  <link rel="stylesheet" href="https://philipjkim.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://philipjkim.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css">

  
  <link rel="stylesheet" href="https://philipjkim.github.io/css/main.min.775ac2af004d44c22a6d000fbd1d9af529642f5cef27399d0280d180af2c2e9b.css">

  
  <link rel="stylesheet" href="https://philipjkim.github.io/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css">

  
  <link rel="stylesheet" href="https://philipjkim.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css">

  
  <link rel="stylesheet" href="https://philipjkim.github.io/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css">

  
  <link rel="stylesheet" href="https://philipjkim.github.io/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css">

  
  <link rel="stylesheet" href="https://philipjkim.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css">

  
  <link rel="stylesheet" href="https://philipjkim.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">







<link rel="shortcut icon" href="https://philipjkim.github.io/favicon.png">
<link rel="apple-touch-icon" href="https://philipjkim.github.io/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="분산 시스템 개발자를 위한 기도">
<meta property="og:description" content="... 스택 꼭대기에 서서 아래를 내려다보니, 그동안 제가 보아온 두 가지 유형 — 그리고 어쩌면 세 번째 유형 — 의 소프트웨어 엔지니어링에 대해 생각하게 되었습니다." />
<meta property="og:url" content="https://philipjkim.github.io/posts/20250701-a-prayer-for-distrubuted-systems-developers/" />
<meta property="og:site_name" content="philipjkim" />

  <meta property="og:image" content="https://philipjkim.github.io/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2025-07-01 13:55:13 &#43;0900 KST" />












</head>
<body>


<div class="container">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    philipjkim
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="https://github.com/philipjkim">GitHub</a></li>
        
      
        
          <li><a href="/dev/hoola-calculator">Hoola Sum Calculator</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="https://github.com/philipjkim" target="_blank">GitHub</a></li>
        
      
        
          <li><a href="/dev/hoola-calculator" >Hoola Sum Calculator</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://philipjkim.github.io/posts/20250701-a-prayer-for-distrubuted-systems-developers/">분산 시스템 개발자를 위한 기도</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-07-01</time><span class="post-author">Philip O&#39;Toole</span></div>

  
    <span class="post-tags">
      
      #<a href="https://philipjkim.github.io/tags/assembler/">assembler</a>&nbsp;
      
      #<a href="https://philipjkim.github.io/tags/cloud/">cloud</a>&nbsp;
      
      #<a href="https://philipjkim.github.io/tags/distributed-systems/">distributed-systems</a>&nbsp;
      
      #<a href="https://philipjkim.github.io/tags/programming/">programming</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <p>원문: <a href="https://philipotoole.com/a-prayer-for-distributed-systems-developers/">https://philipotoole.com/a-prayer-for-distributed-systems-developers/</a> (Translated by Google Gemini)</p>
<hr>
<p>16년이 넘는 시간 동안 저는 전체 스택을 오르내리며 소프트웨어를 작성했습니다. 제 경력 초기에 저는 특수 임베디드 장치를 위한 <a href="http://en.wikipedia.org/wiki/Booting">부트 ROM</a> 소프트웨어를 작성했습니다. 이런 종류의 프로그래밍은 컴퓨터가 <strong>정말로</strong> 어떻게 작동하는지에 대해 많은 것을 가르쳐주었습니다.</p>
<p>대부분의 프로그래머는 컴퓨터가 어떻게 작동하는지 안다고 생각하지만, <strong>그들은 단지 소프트웨어가 어떻게 작동하는지 알 뿐입니다.</strong> 이 프로그래머들은 <a href="http://en.wikipedia.org/wiki/Interrupt_handler">인터럽트 서비스 루틴</a>이 어떻게 호출되는지, 컴퓨터가 두 숫자를 어떻게 더하는지, 마이크로프로세서가 다음 명령어를 RAM에 어떻게 로드하는지 정말로 알지 못합니다. 하지만 괜찮습니다. 그럴 필요도 없고, 관심도 없습니다.</p>
<p>그래서 저는 여러 해 동안 <a href="http://en.wikipedia.org/wiki/Embedded_software">임베디드 소프트웨어</a>를 작성했지만, 상승 기류에 휩쓸린 풍선처럼 소프트웨어 스택 위로 떠올랐습니다. 한동안 <a href="https://www.kernel.org/">커널 공간</a>에서 지내다가, 몇 년간 <a href="http://en.wikipedia.org/wiki/User_space">사용자 공간</a>에서 머물렀고, 가장 최근에는 <a href="http://www.slideshare.net/AmazonWebServices/infrastructure-at-scale-apache-kafka-twitter-storm-elastic-search-arc303-aws-reinvent-2013">엄청난 소프트웨어 스택</a>의 꼭대기에 서게 되었습니다. 하지만 임베디드 소프트웨어만 작성하는 것은 시스템에 대해 거의 가르쳐주지 않으며 — 그렇게 높은 스택을 내려다보면 정신이 아찔해질 수도 있습니다 — <a href="http://www.nlm.nih.gov/medlineplus/dizzinessandvertigo.html">아래를 내려다보지 말라고 하듯이</a>.</p>
<p>하지만 그 스택 꼭대기에 서서 아래를 내려다보니, 그동안 제가 보아온 두 가지 유형 — 그리고 어쩌면 세 번째 유형 — 의 소프트웨어 엔지니어링에 대해 생각하게 되었습니다.</p>
<h2 id="유형-1-소프트웨어-엔지니어링">유형 1 소프트웨어 엔지니어링<a href="#유형-1-소프트웨어-엔지니어링" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>제가 이제부터 설명할 것을 <em>유형 1</em> 소프트웨어 엔지니어링이라고 부릅시다.</p>
<p>임베디드 소프트웨어가 그 예입니다. 입력 조건이 매우 제한적이므로, 소프트웨어가 매우 높은 수준으로 정확하다는 것을 보여주기가 훨씬 쉽습니다. 하드웨어에 매우 가깝기 때문에 동작이 정확하게 측정된 구성 요소에 가까이 있는 이점을 누립니다. 제 경력 동안 저는 수천 개의 어셈블리 명령어를 작성했으며, 이는 CPU 레지스터에서 읽고 썼습니다. 이 명령어들은 항상 정확히 같은 시간(기술적으로는 같은 수의 클럭 사이클)에 실행되었습니다. <a href="http://en.wikipedia.org/wiki/Read-modify-write">읽기-수정-쓰기</a> 주기의 응답성을 모니터링한다는 생각은 프로그래머의 관점에서는 명백히 말도 안 되는 이야기입니다(마이크로프로세서 설계자에게는 그렇지 않겠지만요!).</p>
<p>임베디드 시스템이 실행될 때 — <a href="https://philipotoole.com/resume/tivohd-inside-3-scaled">디지털 비디오 레코더</a>와 같은 더 큰 시스템도 — 다소 수학적인 느낌이 듭니다. 신호가 들어가고, 신호가 나옵니다. 버튼이 눌리고, 디스플레이가 바뀝니다. 제약이 있고, 특정 사고방식으로 이어집니다. 도전 과제는 여전히 중요합니다. 시스템은 종종 물리적으로 매우 작고, 하드웨어는 종종 고도로 맞춤화되어 있으며, 도구는 상대적으로 적습니다. 때로는 오실로스코프를 사용하여 소프트웨어를 디버그해야 하는데 — 제가 해본 일입니다.</p>
<p>하지만 프로그래밍 문제 — 제품 — 은 종종 완료 지점에 도달하여, <em>그 시스템은 완성되었고 모든 상황에서 어떻게 동작할지 안다</em>고 말할 수 있습니다.</p>
<h2 id="유형-2-소프트웨어-엔지니어링">유형 2 소프트웨어 엔지니어링<a href="#유형-2-소프트웨어-엔지니어링" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>이제 제가 <em>유형 2</em>라고 부르는 것에 대해 이야기해 봅시다.</p>
<p>유형 2는 대규모 분산 시스템을 프로그래밍하고 설계하는 것을 포함합니다. 함수 호출은 국가 간 연결을 통해 여러 네트워크 홉을 포함할 수 있습니다. 지연 시간은 구성 요소 전체에 분산되어 있으며, 외부 서비스에 대한 호출은 마이크로초가 걸릴 수도 있고, 몇 분이 걸릴 수도 있습니다. 하위 시스템은 실패 직전일 수 있지만 괜찮아 보일 수 있습니다. 이런 종류의 소프트웨어 설계는 대규모 컴퓨터 시스템에 대한 쉬운 접근의 출현과 함께 오늘날 훨씬 더 널리 퍼져 있습니다.</p>
<p>제 경험상 이러한 시스템을 엔지니어링하는 방법은 단 하나뿐입니다. 프로그래밍에서 배운 모든 것을 활용한 다음, 시스템 엔지니어가 되는 것입니다. 모든 속성은 측정되고 모니터링되어야 하며, 모든 동작은 시간을 재고 기록되어야 합니다. 피드백 루프에 대해 배워야 합니다. 이는 실제 기계 공학과 훨씬 더 유사합니다. 이 모델에서는 소프트웨어의 작동 매개변수가 선택되고 — 종종 지속적으로 변경되며 — 시스템이 어떻게 수행되는지에 주의를 기울이고 필요에 따라 매개변수를 수정함으로써 결정됩니다. 견고한 설계를 지속적인 측정 및 분석과 결합하고, 이를 시스템 운영에 다시 반영하는 것 — 이것이 제가 유형 2 소프트웨어 엔지니어링이라고 생각하는 것입니다.</p>
<p>이상적으로는 유형 2는 유형 1의 상위 집합입니다. 그러나 유형 2 엔지니어링은 운영 특성이 <strong>변화의 유일한 원동력</strong>이 되고, 시스템이 왜 그렇게 작동하는지 <strong>이해하려는 시도 없이</strong> 이루어질 때 무너집니다 — 이를 <em>유형 3 소프트웨어 엔지니어링</em> 또는 더 간결하게 <em>추측</em>이라고 부릅니다. 이는 종종 시간이 부족하거나, 팀이 스트레스에 시달리거나, 시스템이 실패 직전일 때 발생합니다.</p>
<p>분산 시스템 개발자를 위한 <a href="http://en.wikipedia.org/wiki/Serenity_Prayer">평온을 비는 기도</a> 라 부르면 될까요?</p>
<blockquote>
<p><em>신이시여, 제가 바꿀 수 없는 것을 받아들이는 설계 능력을 주시고,</em></p>
<p><em>제가 바꿀 수 있는 것을 바꾸는 코드를 주시고,</em></p>
<p><em>그 차이를 알 수 있는 측정 지표를 주소서.</em></p></blockquote>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">Read other posts</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
    
    
      <a href="https://philipjkim.github.io/posts/20250630-java-thread-vs-virtual-thread-vs-kotlin-coroutine/" class="button inline next">
         [<span class="button__text">Java 스레드 성능 vs. 가상 스레드 vs. Kotlin 코루틴</span>] &gt;
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2025 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
