<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vibe-Coding on philipjkim</title>
    <link>https://philipjkim.github.io/tags/vibe-coding/</link>
    <description>Recent content in Vibe-Coding on philipjkim</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Thu, 31 Jul 2025 11:55:18 +0900</lastBuildDate>
    <atom:link href="https://philipjkim.github.io/tags/vibe-coding/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go 는 왜 LLM 기반 Vibe-Coding에 적합한 언어인가?</title>
      <link>https://philipjkim.github.io/posts/20250731-golang-for-vibe-coding/</link>
      <pubDate>Thu, 31 Jul 2025 11:55:18 +0900</pubDate>
      <guid>https://philipjkim.github.io/posts/20250731-golang-for-vibe-coding/</guid>
      <description>&lt;p&gt;이 글에서는 LLM을 활용한 Vibe-Coding 시대에 Go 언어가 가지는 장점들을 알아봅니다.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;(영문 글을 번역했던 블로그 대부분의 포스트와는 달리 이 글은 제가 초안을 작성하고, Gemini 의 도움을 받아 개선된 originality 가 있는 글입니다.)&lt;/em&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;1-강력한-정적-타입-시스템과-컴파일-단계&#34;&gt;1. 강력한 정적 타입 시스템과 컴파일 단계&lt;/h2&gt;&#xA;&lt;p&gt;Go는 정적 타입 언어이며 컴파일을 통해 실행 파일을 만듭니다. 이는 코드가 실행되기 전, 즉 컴파일 시점에 타입 불일치, 함수 인자 오류, 존재하지 않는 변수 참조 등 수많은 오류를 미리 잡아낼 수 있음을 의미합니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gemini CLI: 소개 및 그 진정한 가치</title>
      <link>https://philipjkim.github.io/posts/20250730-gemini-cli-an-introduction-and-its-real-value/</link>
      <pubDate>Wed, 30 Jul 2025 09:08:43 +0900</pubDate>
      <guid>https://philipjkim.github.io/posts/20250730-gemini-cli-an-introduction-and-its-real-value/</guid>
      <description>&lt;p&gt;&lt;em&gt;원문: &lt;a href=&#34;https://medium.com/@terrycho/gemini-cli-an-introduction-and-its-real-value-15bd070fb011&#34;&gt;https://medium.com/@terrycho/gemini-cli-an-introduction-and-its-real-value-15bd070fb011&lt;/a&gt; (translated by Google Gemini)&lt;/em&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;얼마 전, Gemini CLI 발표 직후 구글의 Gemini 서버가 과부하되었다는 소식이 들려왔습니다. 사람들은 왜 Gemini CLI에 그렇게 열광하는 걸까요? 우리는 이미 웹과 데스크톱에서 사용할 수 있는 ChatGPT와 Claude, 그리고 Cursor와 Windsurf 같은 코딩 AI 도구, 심지어 Lovable과 V0 같은 바이브 코딩 도구까지 가지고 있습니다. 터미널 기반의 새로운 CLI 기반 AI가 이 시장에 어떤 영향을 미칠 수 있을까요?&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mnQoAMyjje5FOHG5TT85qA.png&#34; alt=&#34;img1&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;무료 서비스 발표가 상당한 인기를 얻었지만, Gemini CLI는 전체 소프트웨어 개발 수명 주기(SDLC)를 아우르는 오케스트레이터로서 새로운 입지를 확립했습니다. 이는 소프트웨어 개발 전체를 포괄하려는 야심 찬 계획을 엿볼 수 있게 합니다. 이 글에서는 Gemini CLI가 왜 그렇게 인기 있는지, 그 특징과 차별점, 숨겨진 가치, 그리고 미래 개발 가능성에 대해 논의할 것입니다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
