<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vibe-Coding on philipjkim</title>
    <link>https://philipjkim.github.io/tags/vibe-coding/</link>
    <description>Recent content in Vibe-Coding on philipjkim</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 06 Aug 2025 09:22:00 +0900</lastBuildDate>
    <atom:link href="https://philipjkim.github.io/tags/vibe-coding/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>증강 코딩: 바이브를 넘어</title>
      <link>https://philipjkim.github.io/posts/20250806-augmented-coding-beyond-the-vibes/</link>
      <pubDate>Wed, 06 Aug 2025 09:22:00 +0900</pubDate>
      <guid>https://philipjkim.github.io/posts/20250806-augmented-coding-beyond-the-vibes/</guid>
      <description>&lt;p&gt;원문: &lt;a href=&#34;https://tidyfirst.substack.com/p/augmented-coding-beyond-the-vibes&#34;&gt;https://tidyfirst.substack.com/p/augmented-coding-beyond-the-vibes&lt;/a&gt; (Translated by Google Gemini)&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;이 글의 존재를 알려준 &lt;a href=&#34;mailto:r@rsl.kr&#34;&gt;r@rsl.kr&lt;/a&gt; 에게 감사를 표합니다.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;최근 증강 코딩을 사용하여 B+ 트리 라이브러리를 구축하려는 야심 찬 프로젝트에서 좋은 마무리를 지었습니다. 그 결과물은 &lt;a href=&#34;https://github.com/KentBeck/BPlusTree3&#34;&gt;&lt;em&gt;BPlusTree3&lt;/em&gt;&lt;/a&gt; - Rust 및 Python으로 구현된 성능 경쟁력이 있고, 어쩌면 프로덕션에 즉시 사용 가능한 구현입니다. 저는 친구와 앉아 저의 이야기를 나누고 GenAI 시대의 프로그래밍 미래에 대해 무엇을 시사하는지 생각해 보았습니다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;무엇이-당신을-b-트리를-먼저-구현하게-만들었나요&#34;&gt;무엇이 당신을 B+ 트리를 먼저 구현하게 만들었나요?&lt;/h2&gt;&#xA;&lt;p&gt;증강 코딩의 놀라운 힘을 깨닫기 시작했을 때, 저는 과거에 기술적으로 접근하기 어려웠던 프로젝트들을 떠올리기 시작했습니다. 그중 하나는 특수 목적 데이터베이스였습니다. 지금 그 데이터베이스 프로젝트를 구현하면서 B+ 트리 데이터 구조를 충분히 이해하지 못했다는 것을 깨달았고 그래서 목표를 바꿨습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>AI 코딩 시대의 그림자: LLM 의존이 개발자에게 미치는 잠재적 위험 5가지</title>
      <link>https://philipjkim.github.io/posts/20250805-shadows-of-ai-coding-era/</link>
      <pubDate>Tue, 05 Aug 2025 16:12:15 +0900</pubDate>
      <guid>https://philipjkim.github.io/posts/20250805-shadows-of-ai-coding-era/</guid>
      <description>&lt;p&gt;&lt;code&gt;vibe-coding&lt;/code&gt;, &lt;code&gt;agent-coding&lt;/code&gt; 이라는 말이 어색하지 않은 시대입니다. Claude, Gemini, GitHub Copilot과 같은 LLM(거대 언어 모델) 기반 코딩 도구들은 이제 단순히 코드 스니펫을 자동 완성해주는 수준을 넘어, 우리의 생각을 논리적으로 설명하면 프로젝트 전체의 구조를 짜고 방대한 양의 코드를 순식간에 만들어냅니다. 생산성의 혁신이라 부를 만한 이 변화는 분명 경이롭습니다.&lt;/p&gt;&#xA;&lt;p&gt;하지만 이 강력한 도구에 과도하게 의존하기 시작하면서, 우리는 이전에 겪어보지 못한 새로운 종류의 문제들에 직면하고 있습니다. 밝은 빛이 강할수록 그림자도 짙어지는 법입니다. 지난 주말 바이브코딩을 직접 경험해 보며 그런 그림자의 영역을 빠르게 체감할 수 있었습니다. 이 글에서는 LLM 기반 코딩에 대한 의존이 개발자 개인과 팀에 미칠 수 있는 5가지 잠재적 위험을 심도 있게 다뤄보고자 합니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 는 왜 LLM 기반 Vibe-Coding에 적합한 언어인가?</title>
      <link>https://philipjkim.github.io/posts/20250731-golang-for-vibe-coding/</link>
      <pubDate>Thu, 31 Jul 2025 11:55:18 +0900</pubDate>
      <guid>https://philipjkim.github.io/posts/20250731-golang-for-vibe-coding/</guid>
      <description>&lt;p&gt;이 글에서는 LLM을 활용한 Vibe-Coding 시대에 Go 언어가 가지는 장점들을 알아봅니다.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;(영문 글을 번역했던 블로그 대부분의 포스트와는 달리 이 글은 제가 초안을 작성하고, Gemini 의 도움을 받아 개선된 originality 가 있는 글입니다.)&lt;/em&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;1-강력한-정적-타입-시스템과-컴파일-단계&#34;&gt;1. 강력한 정적 타입 시스템과 컴파일 단계&lt;/h2&gt;&#xA;&lt;p&gt;Go는 정적 타입 언어이며 컴파일을 통해 실행 파일을 만듭니다. 이는 코드가 실행되기 전, 즉 컴파일 시점에 타입 불일치, 함수 인자 오류, 존재하지 않는 변수 참조 등 수많은 오류를 미리 잡아낼 수 있음을 의미합니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gemini CLI: 소개 및 그 진정한 가치</title>
      <link>https://philipjkim.github.io/posts/20250730-gemini-cli-an-introduction-and-its-real-value/</link>
      <pubDate>Wed, 30 Jul 2025 09:08:43 +0900</pubDate>
      <guid>https://philipjkim.github.io/posts/20250730-gemini-cli-an-introduction-and-its-real-value/</guid>
      <description>&lt;p&gt;&lt;em&gt;원문: &lt;a href=&#34;https://medium.com/@terrycho/gemini-cli-an-introduction-and-its-real-value-15bd070fb011&#34;&gt;https://medium.com/@terrycho/gemini-cli-an-introduction-and-its-real-value-15bd070fb011&lt;/a&gt; (translated by Google Gemini)&lt;/em&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;얼마 전, Gemini CLI 발표 직후 구글의 Gemini 서버가 과부하되었다는 소식이 들려왔습니다. 사람들은 왜 Gemini CLI에 그렇게 열광하는 걸까요? 우리는 이미 웹과 데스크톱에서 사용할 수 있는 ChatGPT와 Claude, 그리고 Cursor와 Windsurf 같은 코딩 AI 도구, 심지어 Lovable과 V0 같은 바이브 코딩 도구까지 가지고 있습니다. 터미널 기반의 새로운 CLI 기반 AI가 이 시장에 어떤 영향을 미칠 수 있을까요?&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mnQoAMyjje5FOHG5TT85qA.png&#34; alt=&#34;img1&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;무료 서비스 발표가 상당한 인기를 얻었지만, Gemini CLI는 전체 소프트웨어 개발 수명 주기(SDLC)를 아우르는 오케스트레이터로서 새로운 입지를 확립했습니다. 이는 소프트웨어 개발 전체를 포괄하려는 야심 찬 계획을 엿볼 수 있게 합니다. 이 글에서는 Gemini CLI가 왜 그렇게 인기 있는지, 그 특징과 차별점, 숨겨진 가치, 그리고 미래 개발 가능성에 대해 논의할 것입니다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
