<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Queue on philipjkim</title>
    <link>https://philipjkim.github.io/tags/queue/</link>
    <description>Recent content in Queue on philipjkim</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Thu, 26 Feb 2026 19:38:55 +0900</lastBuildDate>
    <atom:link href="https://philipjkim.github.io/tags/queue/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Redis를 활용한 초경량 메시징 전략: Pub-Sub과 Worker Queue 완벽 정리</title>
      <link>https://philipjkim.github.io/posts/20260226-redis-for-message-queue/</link>
      <pubDate>Thu, 26 Feb 2026 19:38:55 +0900</pubDate>
      <guid>https://philipjkim.github.io/posts/20260226-redis-for-message-queue/</guid>
      <description>&lt;p&gt;Redis를 단순히 &amp;lsquo;캐시&amp;rsquo;로만 쓰고 계신가요? 사실 Redis는 백엔드 엔지니어의 도구 상자에서 가장 다재다능한 &lt;strong&gt;&amp;lsquo;메시지 브로커&amp;rsquo;&lt;/strong&gt; 이기도 합니다. 별도의 무거운 MQ(Message Queue)를 설치하기엔 부담스럽고, 속도는 포기할 수 없을 때 Redis는 최고의 선택지가 됩니다.&lt;/p&gt;&#xA;&lt;p&gt;Go 언어를 이용해 Redis의 두 가지 핵심 메시징 패턴인 &lt;strong&gt;Pub-Sub&lt;/strong&gt;과 &lt;strong&gt;Worker Queue&lt;/strong&gt;를 구현하는 방법을 정리해 보았습니다.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;1-왜-redis-메시지-큐인가&#34;&gt;1. 왜 Redis 메시지 큐인가?&lt;/h2&gt;&#xA;&lt;p&gt;RabbitMQ나 Kafka는 훌륭하지만, 운영 오버헤드가 큽니다. 반면 Redis는 이미 많은 프로젝트에서 캐시용으로 사용 중이며, 다음과 같은 장점이 있습니다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
